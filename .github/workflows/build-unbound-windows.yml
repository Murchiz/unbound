name: Build Unbound for Windows (Latest Release)

on:
  workflow_dispatch: # Allows manual triggering
  # push: # Optional: trigger on pushes to a specific branch
  #   branches: [ main ]

jobs:
  build-windows-release:
    runs-on: windows-latest

    env:
      # Define versions here for easier updates, matching the official workflow
      OPENSSL_VERSION_NUMBER: "3.2.0"
      OPENSSL_DIR_NAME: "openssl-3.2.0" # Directory name after extraction
      OPENSSL_TARBALL: "openssl-3.2.0.tar.gz"
      OPENSSL_DOWNLOAD_URL: "https://www.openssl.org/source/openssl-3.2.0.tar.gz"

      LIBEXPAT_DIR_NAME: "expat-2.7.0"        # Directory name after extraction (from official LIBEXPAT_FNAME)
      LIBEXPAT_VERSION_TAG_DIR: "R_2_7_0"   # Tag directory for download (from official LIBEXPAT_VERSION_DIR)
      LIBEXPAT_TARBALL: "expat-2.7.0.tar.gz"  # LIBEXPAT_FNAME + .tar.gz

    steps:
    - name: Fetch Latest Unbound Release Tag
      id: get_latest_release
      uses: pozetroninc/github-action-get-latest-release@master
      with:
        repository: NLnetLabs/unbound
        excludes: prerelease, draft # Ensure we get stable releases

    - name: Display Latest Release Tag
      run: echo "Latest Unbound release is ${{ steps.get_latest_release.outputs.release }}"

    - name: Download and Extract Latest Unbound Release Source
      shell: pwsh # PowerShell for initial setup and download
      run: |
        $LatestTag = "${{ steps.get_latest_release.outputs.release }}"
        # GitHub archives from tags are typically named <tag>.tar.gz or <tag>.zip
        # The directory inside the tarball is often <repo>-<tag> or <repo>-<stripped-tag>
        $TarballFileName = "$LatestTag.tar.gz"
        $DownloadUrl = "https://github.com/NLnetLabs/unbound/archive/refs/tags/$LatestTag.tar.gz"

        Write-Host "Downloading Unbound version $LatestTag from $DownloadUrl"
        Invoke-WebRequest -Uri $DownloadUrl -OutFile unbound-release.tar.gz
        tar -xzf unbound-release.tar.gz

        # Find the extracted folder name (e.g., unbound-release-1.20.0)
        $ExtractedFolderName = (Get-ChildItem -Directory -Filter "unbound-*" | Select-Object -First 1).Name
        if (-not $ExtractedFolderName) {
          Write-Error "Could not find extracted Unbound folder."
          exit 1
        }
        Move-Item -Path $ExtractedFolderName -Destination "unbound-src"
        Write-Host "Successfully downloaded and extracted Unbound to $(Get-Location)\unbound-src"

        # Set PREPATH for subsequent bash steps. It will be the GitHub Workspace root.
        echo "PREPATH=$((Resolve-Path .).Path.Replace('\', '/'))" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

    - name: Install Tools and Build Dependencies
      shell: bash # Crucial for ./configure and make scripts used by OpenSSL, Expat, and Unbound
      env:
        # PREPATH is set from the previous PowerShell step and available here
        LEX: "win_flex"
        YACC: "win_bison -y"
      run: |
        echo "PREPATH (Workspace) is: $PREPATH"

        echo "Installing winflexbison3..."
        choco install winflexbison3 --no-progress -y

        echo "Building OpenSSL..."
        cd "$PREPATH" # Ensure we are in the workspace root
        mkdir -p openssl_build_dir # Directory to download and build OpenSSL
        cd openssl_build_dir
        curl -L -k -s -S -o "${{ env.OPENSSL_TARBALL }}" "${{ env.OPENSSL_DOWNLOAD_URL }}"
        tar xzf "${{ env.OPENSSL_TARBALL }}"
        cd "${{ env.OPENSSL_DIR_NAME }}" # e.g., openssl-3.2.0

        OPENSSL_INSTALL_PATH="$PREPATH/openssl_install"
        echo "Configuring OpenSSL to install into $OPENSSL_INSTALL_PATH"
        # Using Perl from Git for Windows, which is usually available on GitHub runners
        # The official workflow uses C:/msys64/usr/bin/perl. If that path is more reliable on the specific runner, adjust.
        # PERL="C:/Program Files/Git/usr/bin/perl.exe" also works for the Configure script.
        "C:/Program Files/Git/usr/bin/perl.exe" ./Configure no-shared no-asm -DOPENSSL_NO_CAPIENG mingw64 --prefix="$OPENSSL_INSTALL_PATH" --openssldir="$OPENSSL_INSTALL_PATH" PERL="C:/Program Files/Git/usr/bin/perl.exe"

        echo "Making OpenSSL (build_libs)..."
        make build_libs # Faster, as in official workflow
        echo "Installing OpenSSL (install_dev)..."
        make install_dev # Installs headers and libs, as in official workflow

        echo "Building Expat..."
        cd "$PREPATH" # Back to workspace root
        mkdir -p expat_build_dir # Directory to download and build Expat
        cd expat_build_dir
        EXPAT_DOWNLOAD_URL="https://github.com/libexpat/libexpat/releases/download/${{ env.LIBEXPAT_VERSION_TAG_DIR }}/${{ env.LIBEXPAT_DIR_NAME }}.tar.gz"
        curl -L -k -s -S -o "${{ env.LIBEXPAT_TARBALL }}" "$EXPAT_DOWNLOAD_URL"
        tar xzf "${{ env.LIBEXPAT_TARBALL }}"
        cd "${{ env.LIBEXPAT_DIR_NAME }}" # e.g., expat-2.7.0

        EXPAT_INSTALL_PATH="$PREPATH/expat_install"
        echo "Configuring Expat to install into $EXPAT_INSTALL_PATH"
        # Using SHELL=/usr/bin/bash and CONFIG_SHELL=/usr/bin/bash as in official workflow for Expat's configure
        ./configure SHELL=/usr/bin/bash CONFIG_SHELL=/usr/bin/bash --prefix="$EXPAT_INSTALL_PATH" --exec-prefix="$EXPAT_INSTALL_PATH" --bindir="$EXPAT_INSTALL_PATH/bin" --includedir="$EXPAT_INSTALL_PATH/include" --mandir="$EXPAT_INSTALL_PATH/man" --libdir="$EXPAT_INSTALL_PATH/lib"

        echo "Fixing Expat Makefiles (SHELL -> SHELLZZ)..."
        find . -name "Makefile" -exec sed -i 's/^SHELL\s*=/SHELLZZ =/g' {} \; # More robust sed for SHELL variable

        echo "Making Expat..."
        make
        echo "Installing Expat..."
        make install

    - name: Configure and Build Unbound
      shell: bash # Unbound's ./configure and make also expect a bash-like environment
      env:
        # PREPATH is from GITHUB_ENV
        LEX: "win_flex"
        YACC: "win_bison -y"
      run: |
        echo "Configuring Unbound from $PREPATH/unbound-src..."
        cd "$PREPATH/unbound-src" # Navigate into the downloaded Unbound source directory

        # Paths for --with-ssl and --with-libexpat must point to our custom install locations
        OPENSSL_INSTALL_PATH_UNIX=$(echo "$PREPATH/openssl_install" | sed 's/\\/\//g')
        EXPAT_INSTALL_PATH_UNIX=$(echo "$PREPATH/expat_install" | sed 's/\\/\//g')

        echo "Using OpenSSL from: $OPENSSL_INSTALL_PATH_UNIX"
        echo "Using Expat from: $EXPAT_INSTALL_PATH_UNIX"

        # Configure Unbound using flags from the official workflow
        ./configure --enable-debug --enable-static-exe --disable-flto "--with-ssl=$OPENSSL_INSTALL_PATH_UNIX" "--with-libexpat=$EXPAT_INSTALL_PATH_UNIX" --disable-shared

        echo "Making Unbound..."
        make

        echo "Running Unbound tests (optional)..."
        make test

    - name: Prepare Artifacts
      shell: pwsh
      run: |
        New-Item -ItemType Directory -Force -Path staging
        $SourceDir = "${{ env.PREPATH }}/unbound-src" # PREPATH is available as an env var
        Write-Host "Looking for binaries in $SourceDir"

        Copy-Item -Path "$SourceDir/unbound.exe" -Destination "./staging/" -ErrorAction SilentlyContinue
        Copy-Item -Path "$SourceDir/unbound-checkconf.exe" -Destination "./staging/" -ErrorAction SilentlyContinue
        Copy-Item -Path "$SourceDir/unbound-anchor.exe" -Destination "./staging/" -ErrorAction SilentlyContinue
        # libunbound.dll is not expected with --disable-shared and --enable-static-exe

        # Copy LICENSE and example config if they exist in the source root
        if (Test-Path "$SourceDir/LICENSE") { Copy-Item "$SourceDir/LICENSE" -Destination "./staging/" }
        if (Test-Path "$SourceDir/doc/example.conf") { Copy-Item "$SourceDir/doc/example.conf" -Destination "./staging/" }

        Write-Host "Staging directory content:"
        Get-ChildItem ./staging

    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: unbound-windows-${{ steps.get_latest_release.outputs.release }}
        path: staging/
        if-no-files-found: error # Fails the workflow if no binaries were copied
